死锁：两个或多个线程都在等待对方释放资源，都停止执行的情形，某一个同步块同时拥有"两个以上对象的锁"时，就可能会发生"死锁"问题。
产生死锁的四个必要条件：
1、互斥条件：一个资源每次只能被一个进程使用
2、请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
3、不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺；
4、循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系；

只要破坏其中的任意一个或多个条件就可以避免死锁发生

synchronzed 隐式的锁


Lock 锁，显示的锁
java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具，锁提供了对共享资源的独占访问，ReentrantLock（可重入锁）类实现了Lock ,比较常用，可以显示加锁、释放锁。

synchronized 与 Lock 对比
1、Lock是显示锁，手动开启和关闭锁，别忘记关闭锁；synchronized是隐式锁，出了作用域自动释放
2、Lock 只有代码块锁，synchronized有代码块锁和方法锁
3、使用Lock锁，JVM将花费较少的时间来调度线程，性能更高，并且具有更好的扩展性（提供更多的子类）
4、优先使用顺序：Lock > 同步代码块(已经进入了方法体，分配了相应资源) > 同步方法(在方法体之外)